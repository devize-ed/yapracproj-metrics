package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/devize-ed/yapracproj-metrics.git/internal/logger"
	"go.uber.org/zap"
)

const resetComment = "// generate:reset"

const templateStr = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by reset.go

package {{.Package}}

func ({{.Recv}} *{{.TypeName}}) Reset() {
	if {{.Recv}} == nil {
		return
	}
{{range .FieldResets}}
	{{.}}
{{end}}
}
`

func main() {
	// initialize the logger with the specified log level
	logger, err := logger.Initialize("debug")
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := logger.Sync(); err != nil {
			logger.Errorf("failed to sync logger: %v", err)
		}
	}()

	if err := run(logger); err != nil {
		logger.Errorf("failed to run: %v", err)
		os.Exit(1)
	}
}

func run(logger *zap.SugaredLogger) error {
	// prepare template
	tpl, err := template.New("reset").Parse(templateStr)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// search for structs to reset in the project directory
	root := "."
	walkErr := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("failed to walk the directory: %w", err)
		}
		// if the path is a directory, skip it
		if info.IsDir() {
			return nil
		}
		// if the path is not a go file, skip it
		if !strings.HasSuffix(path, ".go") {
			return nil
		}
		// skip generated and test files
		if strings.HasSuffix(path, "_reset.go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}
		// search the structures in the file
		return searchStructsInFile(path, tpl, logger)
	})
	// if the error is not nil, return it
	if walkErr != nil {
		return fmt.Errorf("failed to walk the directory: %w", walkErr)
	}

	return nil
}

// searchStructsInFile searches for structures in a file and returns the error
func searchStructsInFile(path string, tpl *template.Template, logger *zap.SugaredLogger) error {
	// parse the file
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		return err
	}
	// find the index of the structs in the parsed file
	structIdxs := findStructsIndex(f, fset)
	// find the structs that are annotated with the reset comment
	structs := findStructs(f, fset, structIdxs)
	// create the reset statements for the structs
	for _, ts := range structs {
		// print the struct name
		logger.Debugf("FOUND struct in %s: %s", path, ts.Name.Name)
		// create the reset statements for the struct
		resets := createResets(ts)
		// write the reset file
		if err := writeResetFile(path, f, ts, resets, tpl); err != nil {
			return err
		}
	}
	return nil
}

// findStructsIndex finds the index of the structs in the file
func findStructsIndex(f *ast.File, fset *token.FileSet) map[int]*ast.TypeSpec {
	// search for the structs in the file
	structIdxs := make(map[int]*ast.TypeSpec)
	// inspect the file
	ast.Inspect(f, func(n ast.Node) bool {
		// check if the node is a type specification
		ts, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}
		// check if the type specification is a struct
		if _, ok := ts.Type.(*ast.StructType); !ok {
			return true
		}
		// get the line number of the struct
		line := fset.Position(ts.Pos()).Line
		// add the struct to the map
		structIdxs[line] = ts
		return true
	})
	// return the map of the structs
	return structIdxs
}

// findStructs returns struct TypeSpecs that are annotated with resetComment
func findStructs(f *ast.File, fset *token.FileSet, structIdxs map[int]*ast.TypeSpec) []*ast.TypeSpec {
	// search for the reset comment in the file
	var result []*ast.TypeSpec
	for _, gr := range f.Comments {
		// check if the comment list is empty
		if len(gr.List) == 0 {
			continue
		}
		// check if the last comment is the reset comment
		last := gr.List[len(gr.List)-1]
		if last.Text != resetComment {
			continue
		}
		// get the line number of the reset comment
		cl := fset.Position(last.Slash).Line
		// check if the struct is in the map
		if ts, ok := structIdxs[cl+1]; ok {
			// add the struct to the result
			result = append(result, ts)
		}
	}
	return result
}

// createResets creates the reset statements for the given struct
func createResets(ts *ast.TypeSpec) []string {
	// search for the reset comment in the file
	var fieldResets []string
	// get the receiver name
	recv := strings.ToLower(string(ts.Name.Name[0]))
	// get the fields of the struct
	fields := ts.Type.(*ast.StructType).Fields.List
	for _, field := range fields {
		// get the name of the field
		name := field.Names[0].Name
		switch ft := field.Type.(type) {
		case *ast.Ident:
			// check if the field is a resetable type
			if lit, ok := identNameReset(ft.Name); ok {
				fieldResets = append(fieldResets, fmt.Sprintf("%s.%s = %s", recv, name, lit))
			} else {
				// if the field is not a resetable type, add the reset statement
				fieldResets = append(fieldResets,
					fmt.Sprintf("if resetter, ok := interface{}(&%s.%s).(interface{ Reset() }); ok { resetter.Reset() }", recv, name),
				)
			}
		case *ast.ArrayType:
			if ft.Len == nil {
				// if the field is a slice, add the reset statement
				fieldResets = append(fieldResets, fmt.Sprintf("%s.%s = %s.%s[:0]", recv, name, recv, name))
			}
		case *ast.MapType:
			// if the field is a map, add the clear statement
			fieldResets = append(fieldResets, fmt.Sprintf("clear(%s.%s)", recv, name))
		case *ast.StarExpr:
			// check if the field is a pointer
			switch et := ft.X.(type) {
			case *ast.Ident:
				if lit, ok := identNameReset(et.Name); ok {
					// if the field is a resetable type, add the reset statement
					fieldResets = append(fieldResets, fmt.Sprintf("if %s.%s != nil { *%s.%s = %s }", recv, name, recv, name, lit))
				} else {
					// if the field is not a resetable type, add the reset statement
					fieldResets = append(fieldResets, fmt.Sprintf("if resetter, ok := interface{}(%s.%s).(interface{ Reset() }); ok && %s.%s != nil { resetter.Reset() }", recv, name, recv, name))
				}
			case *ast.ArrayType:
				if et.Len == nil {
					// if the field is a slice, add the reset statement
					fieldResets = append(fieldResets, fmt.Sprintf("if %s.%s != nil { *%s.%s = (*%s.%s)[:0] }", recv, name, recv, name, recv, name))
				}
			case *ast.MapType:
				// if the field is a map, add the clear statement
				fieldResets = append(fieldResets, fmt.Sprintf("if %s.%s != nil { clear(*%s.%s) }", recv, name, recv, name))
			}
		}
	}
	return fieldResets
}

// writeResetFile renders and writes the reset method for a struct next to its source file
func writeResetFile(path string, f *ast.File, ts *ast.TypeSpec, fieldResets []string, tpl *template.Template) error {
	// get the receiver name
	recv := strings.ToLower(string(ts.Name.Name[0]))
	// get the data for the template
	data := struct {
		Package     string
		TypeName    string
		Recv        string
		FieldResets []string
	}{
		Package:     f.Name.Name,
		TypeName:    ts.Name.Name,
		Recv:        recv,
		FieldResets: fieldResets,
	}
	// render the template
	var buf bytes.Buffer
	// execute the template
	if err := tpl.Execute(&buf, data); err != nil {
		return err
	}

	// write the file
	outDir := filepath.Dir(path)
	filename := filepath.Join(outDir, fmt.Sprintf("%s_reset.go", ts.Name.Name))
	if err := os.WriteFile(filename, buf.Bytes(), 0644); err != nil {
		return err
	}
	return nil
}

// identNameReset returns the zero literal for the identifier name
func identNameReset(name string) (string, bool) {
	switch name {
	case "string":
		return "\"\"", true
	case "bool":
		return "false", true
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
		"float32", "float64",
		"complex64", "complex128",
		"byte", "rune":
		return "0", true
	default:
		return "", false
	}
}
